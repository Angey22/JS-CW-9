//! Видео - 00:00:00...00:37:55

/*
 * Создание "промиса" (в пер. с англ. - "обещания"):
 *  - класс Promise;
 *  - resolve (в пер. с англ. - "принять");
 *  - reject (в пер. с англ. - "отклонить");
 *  - Promise.prototype.then(onResolve, onReject).
 */
//! "Промис" - это специальный тип объекта, который имеет два свойства: "PromiseState" - состояние; "PromiseResult" - результат, и набор методов (функций) прототипа, предназначенных для его обработки: "catch()", "constructor()", "finally()" и "then()".

// Создаем функциональное выражение - "промис", с помощью служебного класса "Promise", и задаем этому классу колл-бек функцию, в которую задаем стандартные параметры "resolve" и "reject".
const promisValue = new Promise((resolve, reject) => {
  // Создаем промежуточную переменную - генератор случайного состояния "true" или "false".
  const canFulfill = Math.random() > 0.5;

  // C помощью "if" иметируем выполнение или отклонение.
  if (canFulfill) {
    // "resolve" - будет в случае успешного выполнения функции.
    resolve('promisValue -> Промис выполнился успешно, с результатом (исполнен, fulfilled)');
  } else {
    // "reject" - будет в случае НЕ успешного выполнения функции.
    reject('promisValue -> Промис выполнился с ошибкой (отклонён, rejected)');
  };
});

// Выводим в лог объект "promisValue".
console.log('promisValue =>', promisValue);
//! Обрати внимание на то, что в лог вышел объект с соответствующим набором свойств, внутри которого уже отображено его состояние и результат.

// Для вывода данных заложеных в параметры "resolve" промиса - "promisValue", необходимо использовать метод "then()".
// promisValue.then(result => console.log(result)); //!!!
//! Обрати внимание на то, что если "промис" получил состояние "reject" - соответствующий лог не выводится в консоль.

// У метода "then()" есть два параметра: "result" - для успешного выполнения промиса, и "error" - для регистрации ошибки. Реализуем использование обоих этих параметров и подставим в них соответствующие колл-бек функции.
promisValue.then(
  result => {
    console.log(result)
  },
   error => {
    console.log(error)
  }
);
// Имена параметров функции не имеют значение, главное помнить про последовательность: 1-й параметр - успех, 2-й - ошибка.


//! 2-й способ использования метода "then()" и его обоих параметров.
promisValue.then(onFulfilled, onRejected);

// Колл-бек функция успешного выполнения промиса
function onFulfilled(result) {
  console.log('onFulfilled -> onFulfilled');
  console.log(`✅ ${result}`);
}

// Колл-бек функция ошибки
function onRejected(error) {
  console.log('onRejected -> onRejected');
  console.log(`❌ ${error}`);
}

// Пример кода функционального выражения "промиса" с использованием таймера (для отложенного вызова).
const promise = new Promise((resolve, reject) => {
  const canFulfill = Math.random() > 0.5;

  setTimeout(() => {
    if (canFulfill) {
      resolve('Промис выполнился успешно, с результатом (исполнен, fulfilled)');
    }

    reject('Промис выполнился с ошибкой (отклонён, rejected)');
  }, 1000);
});


/*
 * Цепочки промисов (chaining)
 * Promise.prototype.catch(error)
 * Promise.prototype.finally()
 */
// Метод "catch()" предназначен для регистрации ошибки выполнения промиса.

// Метод "finally()" предназначен для регистрации окончания работы "промиса" и выполняется не зависимо от того как он выполнился, его результат всегда отображается в конце операции обработки "промиса". 

promise
  .then(onFulfilled)
  .then(x => {
    console.log(x);

    // Пример записи в коде - принудительного вывода ошибки
    // throw new Error('Ошибка во втором "then"'); //!!!
    //! Смотри в консоли как выглядит вывод подобной принудительной ошибки в обоих случаях (когда "then" сработает и когда - нет)!!!

    return 10;
  })
  .then(y => {
    console.log(y);
  })
  .catch(error => console.log(error))
  .finally(() => console.log('Я буду выполнен в любом случае'));
