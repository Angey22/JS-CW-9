{"version":3,"sources":["js_repeta_9-2/01-promise-api.js"],"names":["promisValue","Promise","resolve","reject","Math","random","onFulfilled","result","console","log","concat","onRejected","error","then","promise","canFulfill","setTimeout","x","y","catch","finally"],"mappings":";AAYA,IAAMA,EAAc,IAAIC,QAAQ,SAACC,EAASC,GAErBC,KAAKC,SAAW,GAKjCH,EAAQ,iFAGRC,EAAO,qEA4BX,SAASG,EAAYC,GACnBC,QAAQC,IAAI,8BACZD,QAAQC,IAAGC,KAAAA,OAAMH,IAInB,SAASI,EAAWC,GAClBJ,QAAQC,IAAI,4BACZD,QAAQC,IAAGC,KAAAA,OAAME,IA/BnBJ,QAAQC,IAAI,iBAAkBT,GAQ9BA,EAAYa,KACV,SAAAN,GACEC,QAAQC,IAAIF,IAEb,SAAAK,GACCJ,QAAQC,IAAIG,KAOhBZ,EAAYa,KAAKP,EAAaK,GAe9B,IAAMG,EAAU,IAAIb,QAAQ,SAACC,EAASC,GACpC,IAAMY,EAAaX,KAAKC,SAAW,GAEnCW,WAAW,WACLD,GACFb,EAAQ,kEAGVC,EAAO,qDACN,OAaLW,EACGD,KAAKP,GACLO,KAAK,SAAAI,GAOJ,OANAT,QAAQC,IAAIQ,GAML,KAERJ,KAAK,SAAAK,GACJV,QAAQC,IAAIS,KAEbC,MAAM,SAAAP,GAAK,OAAIJ,QAAQC,IAAIG,KAC3BQ,QAAQ,WAAA,OAAMZ,QAAQC,IAAI","file":"01-promise-api.e010a49d.js","sourceRoot":"../src","sourcesContent":["//! Видео - 00:00:00...00:37:55\n\n/*\n * Создание \"промиса\" (в пер. с англ. - \"обещания\"):\n *  - класс Promise;\n *  - resolve (в пер. с англ. - \"принять\");\n *  - reject (в пер. с англ. - \"отклонить\");\n *  - Promise.prototype.then(onResolve, onReject).\n */\n//! \"Промис\" - это специальный тип объекта, который имеет два свойства: \"PromiseState\" - состояние; \"PromiseResult\" - результат, и набор методов (функций) прототипа, предназначенных для его обработки: \"catch()\", \"constructor()\", \"finally()\" и \"then()\".\n\n// Создаем функциональное выражение - \"промис\", с помощью служебного класса \"Promise\", и задаем этому классу колл-бек функцию, в которую задаем стандартные параметры \"resolve\" и \"reject\".\nconst promisValue = new Promise((resolve, reject) => {\n  // Создаем промежуточную переменную - генератор случайного состояния \"true\" или \"false\".\n  const canFulfill = Math.random() > 0.5;\n\n  // C помощью \"if\" иметируем выполнение или отклонение.\n  if (canFulfill) {\n    // \"resolve\" - будет в случае успешного выполнения функции.\n    resolve('promisValue -> Промис выполнился успешно, с результатом (исполнен, fulfilled)');\n  } else {\n    // \"reject\" - будет в случае НЕ успешного выполнения функции.\n    reject('promisValue -> Промис выполнился с ошибкой (отклонён, rejected)');\n  };\n});\n\n// Выводим в лог объект \"promisValue\".\nconsole.log('promisValue =>', promisValue);\n//! Обрати внимание на то, что в лог вышел объект с соответствующим набором свойств, внутри которого уже отображено его состояние и результат.\n\n// Для вывода данных заложеных в параметры \"resolve\" промиса - \"promisValue\", необходимо использовать метод \"then()\".\n// promisValue.then(result => console.log(result)); //!!!\n//! Обрати внимание на то, что если \"промис\" получил состояние \"reject\" - соответствующий лог не выводится в консоль.\n\n// У метода \"then()\" есть два параметра: \"result\" - для успешного выполнения промиса, и \"error\" - для регистрации ошибки. Реализуем использование обоих этих параметров и подставим в них соответствующие колл-бек функции.\npromisValue.then(\n  result => {\n    console.log(result)\n  },\n   error => {\n    console.log(error)\n  }\n);\n// Имена параметров функции не имеют значение, главное помнить про последовательность: 1-й параметр - успех, 2-й - ошибка.\n\n\n//! 2-й способ использования метода \"then()\" и его обоих параметров.\npromisValue.then(onFulfilled, onRejected);\n\n// Колл-бек функция успешного выполнения промиса\nfunction onFulfilled(result) {\n  console.log('onFulfilled -> onFulfilled');\n  console.log(`✅ ${result}`);\n}\n\n// Колл-бек функция ошибки\nfunction onRejected(error) {\n  console.log('onRejected -> onRejected');\n  console.log(`❌ ${error}`);\n}\n\n// Пример кода функционального выражения \"промиса\" с использованием таймера (для отложенного вызова).\nconst promise = new Promise((resolve, reject) => {\n  const canFulfill = Math.random() > 0.5;\n\n  setTimeout(() => {\n    if (canFulfill) {\n      resolve('Промис выполнился успешно, с результатом (исполнен, fulfilled)');\n    }\n\n    reject('Промис выполнился с ошибкой (отклонён, rejected)');\n  }, 1000);\n});\n\n\n/*\n * Цепочки промисов (chaining)\n * Promise.prototype.catch(error)\n * Promise.prototype.finally()\n */\n// Метод \"catch()\" предназначен для регистрации ошибки выполнения промиса.\n\n// Метод \"finally()\" предназначен для регистрации окончания работы \"промиса\" и выполняется не зависимо от того как он выполнился, его результат всегда отображается в конце операции обработки \"промиса\". \n\npromise\n  .then(onFulfilled)\n  .then(x => {\n    console.log(x);\n\n    // Пример записи в коде - принудительного вывода ошибки\n    // throw new Error('Ошибка во втором \"then\"'); //!!!\n    //! Смотри в консоли как выглядит вывод подобной принудительной ошибки в обоих случаях (когда \"then\" сработает и когда - нет)!!!\n\n    return 10;\n  })\n  .then(y => {\n    console.log(y);\n  })\n  .catch(error => console.log(error))\n  .finally(() => console.log('Я буду выполнен в любом случае'));\n"]}