{"version":3,"sources":["js_repeta_9-2/02-promisification.js"],"names":["fetchPokemonById","id","fetch","concat","then","r","json","onFetchSuccess","pokemon","console","log","onFetchError","error"],"mappings":";AA2FA,IAAMA,EAAmB,SAAAC,GACvB,OAAOC,MAAKC,qCAAAA,OAAsCF,IAAMG,KAAK,SAAAC,GAAC,OAAIA,EAAEC,UAWtE,SAASC,EAAeC,GACtBC,QAAQC,IAAI,oCACZD,QAAQC,IAAIF,GAId,SAASG,EAAaC,GACpBH,QAAQC,IAAI,gCACZD,QAAQC,IAAI,qBACZD,QAAQC,IAAIE","file":"02-promisification.38b96672.js","sourceRoot":"../src","sourcesContent":["//! Видео - 00:37:57...1:19:50\n\n/*\n * Промисификация:\n * - Поблема доступа к результату промиса с колбеком\n * - Функция которая возвращает промис\n */\n\n// const makeOrder = dish => {\n//   const DELAY = 1000;\n\n//   return new Promise((resolve, reject) => {\n//     const passed = Math.random() > 0.5;\n\n//     setTimeout(() => {\n//       if (passed) {\n//         resolve(`✅ Вот ваш заказ: ${dish}`);\n//       }\n\n//       reject('❌ Упс, у нас закончились продукты');\n//     }, DELAY);\n//   });\n// };\n\n// makeOrder('пирожок').then(onMakeOrderSuccess).catch(onMakeOrderError);\n\n// function onMakeOrderSuccess(result) {\n//   console.log('onMakeOrderSuccess');\n//   console.log(result);\n// }\n\n// function onMakeOrderError(error) {\n//   console.log('onMakeOrderError');\n//   console.log(error);\n// }\n\n\n/*\n * Промисификация «синхронных» функций\n * - Promise.resolve()\n * - Promise.reject()\n */\n//! Статические методы \"Promise.resolve()\" и \"Promise.reject()\" позволяют создавать функции, которые мгновенно выдают результаты, на основе заранее известного и использованного в коде функции \"resolve()\" или \"reject()\".\n\n// Пример кода статической функции на основе использования метода \"Promise.resolve()\".\n// const makeOrder = dish => {\n//   return Promise.resolve(`✅ Вот ваш заказ: ${dish}`);\n// };\n\n// Вызов результата промисифисированной функции, основанной на методе \"Promise.resolve()\".\n// makeOrder('пирожок').then(onMakeOrderSuccess);\n\n// Код колл-бека для \"resolve()\".\n// function onMakeOrderSuccess(result) {\n//   console.log('onMakeOrderSuccess');\n//   console.log(result);\n// }\n\n// Код колл-бека для \"reject()\".\n// function onMakeOrderError(error) {\n//   console.log('onMakeOrderError');\n//   console.log(error);\n// }\n\n\n/*\n * Покемоны с https://pokeapi.co/\n */\n// \"fetch()\" - это встроенная в браузер функция, которая используется для формирования запросов на бек-енд. В ответ на такой запрос, бек-енд сервер возвращает промис.\n\n// Ориентировочная структура функции \"fetch()\":\n// function fetch(url) {\n//     return new Promise(...);\n// };\n//! \"fetch()\" - принимает в качестве аргумента ссылку на бек-енд сервис, и возвращает в ответ на запрос \"промис\". \n\n// Пример кода на основе использования метода \"fetch()\". Который выполняет запрос информации по \"1-у\" пакемону.\n// fetch('https://pokeapi.co/api/v2/pokemon/1') //! Внеси ошибку в адресс для проверки блока \"catch()\".\n//     .then(r => r.json()) //! Особенность сервиса, необходимая для получения в ответ на запрос - объекта с пакемоном.\n//     .then(pokemon => {\n//         console.log('Сработал блок \"then()\"');\n//         console.log(pokemon);\n//     })\n//     .catch(error => {\n//         console.log('Сработал блок \"catch()\"')\n//         console.log(error);\n//     });\n\n//!===========================================================\n\n// 2-й пример, на основе использования функционального выражения, с возможностью подстановки значения - \"id\", нужного нам пакемона.\nconst fetchPokemonById = id => {\n  return fetch(`https://pokeapi.co/api/v2/pokemon/${id}`).then(r => r.json());\n};\n\n// Вызываем выражение \"fetchPokemonById\":\n// fetchPokemonById(1).then(onFetchSuccess).catch(onFetchError); //!!!\n\n// fetchPokemonById(2).then(onFetchSuccess).catch(onFetchError); //!!!\n\n// fetchPokemonById(3).then(onFetchSuccess).catch(onFetchError); //!!!\n\n// Колл-бек успеха.\nfunction onFetchSuccess(pokemon) {\n  console.log('onFetchSuccess -> onFetchSuccess');\n  console.log(pokemon);\n}\n\n// Колл-бек ошибки.\nfunction onFetchError(error) {\n  console.log('onFetchError -> onFetchError');\n  console.log('Это в блоке catch');\n  console.log(error);\n}\n\n//!===========================================================\n\n// Еще один пример по созданию \"промиса\".\n// makePromise\n// const makePromise = () => {\n//   return new Promise((resolve, reject) => {\n//     const passed = Math.random() > 0.5;\n\n//     setTimeout(() => {\n//       if (passed) {\n//         resolve('✅ Куку это resolve');\n//       }\n\n//       reject('❌ все пропало это reject');\n//     }, 2000);\n//   });\n// };\n\n// makePromise()\n//   .then(result => console.log(result))\n//   .catch(error => console.log(error));\n\n\n//! Примечание:\n// При срабатывании внутри функции-промиса одного из его двух методов-аргументов \"resolve()\" или \"reject()\" - автоматически происходит прерывание работы соответствующей функции, как при \"return\". При этом, само служебное слово \"return\" для прерывания работы функции - можно НЕ ставить, его присутствие ни на что НЕ повлияет.\n"]}